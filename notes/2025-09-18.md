---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.17.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Visualization



## Plotting in Python

There are several popular plotting libaries:
- [matplotlib](https://matplotlib.org/): low level plotting tools
- [seaborn](https://seaborn.pydata.org/index.html): high level plotting with opinionated defaults
- [ggplot](https://yhat.github.io/ggpy/): plotting based on the ggplot library in R.

Plus pandas has a `plot` method

Pandas and seaborn use matplotlib under the hood.

Seaborn and ggplot both assume the data is set up as a DataFrame.
Getting started with seaborn is the simplest, so we'll use that.

+++


## Figure and axis level plots

![summary of plot types](https://seaborn.pydata.org/_images/function_overview_8_0.png)

add the image to your notebook with the following:
```
![summary of plot types](https://seaborn.pydata.org/_images/function_overview_8_0.png)
```
+++

## Anatomy of a figure
![annotated graph](https://matplotlib.org/stable/_images/sphx_glr_anatomy_001.png)


*this was [drawn with code](https://matplotlib.org/stable/gallery/showcase/anatomy.html#anatomy-of-a-figure)

add the image to your notebook with the following:
```
![annotated graph](https://matplotlib.org/stable/_images/sphx_glr_anatomy_001.png)
```

+++

[figure vs axes](https://seaborn.pydata.org/tutorial/function_overview.html#relative-merits-of-figure-level-functions)


we will load pandas and seaborn

```{code-cell} ipython3
import pandas as pd
import seaborn as sns
```

and we will use a new dataset for today with more rows: 
```{code-cell} ipython3
arabica_data_url = 'https://raw.githubusercontent.com/jldbc/coffee-quality-database/master/data/arabica_data_cleaned.csv'
```

then load it in as normal
```{code-cell} ipython3
coffee_df = pd.read_csv(arabica_data_url,index_col=0)
```

since it's new, we will take a quick look with `head`
```{code-cell} ipython3
coffee_df.head()
```

and then see the shape to know how big it is before we start working

```{code-cell} ipython3
coffee_df.shape
```

```{code-cell} ipython3
coffee_df['Flavor'].describe()
```

## Distribution Plots

```{important}
For `seaborn` the online documentation is **immensely** valuable.  Every function's page has basic documentation and lots of examples, so you can see how they use different paramters to modify plots visually. I **strongly recommend reading it often**. I recommend reading [their tutorial too](https://seaborn.pydata.org/tutorial/introduction.html)
```


```{code-cell} ipython3
sns.displot(data=coffee_df,x='Flavor')
```

```{code-cell} ipython3
sns.displot(data=coffee_df,x='Flavor',kind='kde')
```

```{code-cell} ipython3
sns.displot(data=coffee_df,x='Flavor',kind='kde',hue='Color')
```

## Relation Plots

```{code-cell} ipython3
sns.relplot(data=coffee_df, x='Flavor',y='Balance')
```

```{code-cell} ipython3
sns.relplot(data=coffee_df, x='Flavor',y='Balance',hue='Color')
```

```{code-cell} ipython3
coffee_df.columns
```

```{code-cell} ipython3
sns.relplot(data=coffee_df, x='Flavor',y='Balance',hue='Color',col='Country.of.Origin',col_wrap=4)
```

## Categorical Plots

By default a `catplot` is a [stripplot](https://seaborn.pydata.org/generated/seaborn.stripplot.html#seaborn.stripplot)


```{code-cell} ipython3
sns.catplot(coffee_df, y='Number.of.Bags', x='Country.of.Origin')
```

For this data, this is really hard to understand, let's change to a bar version

```{code-cell} ipython3
sns.catplot(coffee_df, y='Number.of.Bags', x='Country.of.Origin',kind='bar')
```

Here, it takes the mean for each country and that is the bar height and the line is the std for each country.

It uses logic similar to:


```{code-cell} ipython3
coffee_df.groupby('Country.of.Origin')['Number.of.Bags'].describe()
```

### Filtering with `isin`

First we can find the top countries, we noticed that the `value_counts` are sorted so we take the first 10
```{code-cell} ipython3
top_countries = coffee_df['Country.of.Origin'].value_counts()[:10].index
top_countries
```

we can use that to filter the original `DataFrame`. To do this, we use [`isin`](https://pandas.pydata.org/docs/reference/api/pandas.Series.isin.html#pandas.Series.isin) to check each element in the `'Country.of.Origin'` column is in that list. 

```{code-cell} ipython3
coffee_df['Country.of.Origin'].isin(top_countries)
```

This is roughly equivalent to: 
```{code-cell} ipython3
[country in top_countries for country in coffee_df['Country.of.Origin'] ]
```
except this builds a list and the pandas way makes a `pd.Series` object. The Python [`in` operator](https://docs.python.org/3/reference/expressions.html#in) is really helpful to know and pandas offers us an `isin` method to get that type of pattern. 

In a more basic programming format this process would be two separate loops worth of work. 
```{code-cell} ipython3
c_in = []
# iterate over the country of each rating
for country in coffee_df['Country.of.Origin']:
    # make a false temp value
    cur_search = False
    # iterate over top countries
    for tc in top_countries:
        # flip the value if the current top & rating cofee match
        if tc==country:
            cur_search = True
    # save the result of the search
    c_in.append(cur_search)
```

```{admonition} Try it yourself
Run these versions and confirm for yourself that they are the same. 
```


With that list of booleans, we can then [mask the original DataFrame](https://pandas.pydata.org/docs/user_guide/indexing.html#boolean-indexing). This keeps only the value where the inner quantity is `True`

```{code-cell} ipython3
top_coffee_df = coffee_df[coffee_df['Country.of.Origin'].isin(top_countries)]
top_coffee_df.head(1)
```

And now we can plot from that new dataframe
```{code-cell} ipython3
sns.catplot(data =top_coffee_df,x='Country.of.Origin',y='Number.of.Bags', aspect=3)
```

Now with the stripplot we can see that it puts a point for each coffee (row in the dataframe) and adds random jitter so they do not all overlap since the x values are the countries which are discrete

## Install some extra tools 
```Python
pip install jupytext mystmd
```

## Variable types and data types

Related but not the same.

+++

Data types are literal, related to the representation in the computer.

ther can be `int16, int32, int64`

+++

We can also have mathematical types of numbers

- Integers can be positive, 0, or negative.
- Reals are continuous, infinite possibilities.
+++
Variable types are about the meaning in a conceptual sense.

- categorical (can take a discrete number of values, could be used to group data,
  could be a string or integer; unordered)
- continuous (can take on any possible value, always a number)
- binary (like data type boolean, but could be represented as yes/no, true/false,
  or 1/0, could be categorical also, but often makes sense to calculate rates)
- ordinal (ordered, but appropriately categorical)

we'll focus on the first two most of the time. Some values that are technically
only integers range high enough that we treat them more like continuous most of
the time.

## Grading Review

We discussed the [grading](../syllabus/grading.md)

## Assignment 1 Q&A

:::::{important}
if you missed class use prismia to find the `portfolio` link and accept the assignment
:::::::

For this assignment if you atted Friday office hours you can get an automatic extension, but going forward the [policy](#extension) will apply. 

## Questions After Class

### Why did you use the . in between spaces for country of origin?

because that is how the column is actually named. 

We are picking out the column name, not just describing it. 

```{code-cell} ipython3
coffee_df.columns
```

If we pick any of those values we get that column: 
```{code-cell} ipython3
from numpy.random import choice
random_col = choice(coffee_df.columns)
coffee_df[random_col].head()
```

or any other one

```{code-cell} ipython3
random_col = choice(coffee_df.columns)
coffee_df[random_col].head()
```

```{code-cell} ipython3
:tags: [raises-exception]
typo_col = 'country of origin'
coffee_df[typo_col].head()
```

this is because {eval}`typo_col` is not a column in the dataset
```{code-cell} ipython3
typo_col in coffee_df.columns
```


###  is the random jitter for same number inclusive or exclude (can the dots overlap  completely if unlucky)

it is random, so they can overlap, but it would be exceedingly unlucky for more than two to cmopletely overlap
