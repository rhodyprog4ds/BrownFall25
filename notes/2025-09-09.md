---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.17.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Python Review



## Closing Jupyter server.

In the terminal use <kbd>Ctrl</kbd> +<kbd>C</kbd> (actually control, not command, on mac).

It will ask you a question and give options, read and follow 


**or**

do <kbd>Ctrl</kbd> +<kbd>C</kbd> a second time. 

A jupyter server typically runs at `localhost:8888`, but if you have multiple servers running the count increases. 


Once I saw a student in office hours working on `localhost:8894` asking why their code kept crashing.

```{important}
Remember to close your jupyter server
```

+++

## Functions

To define a function in Python we use the `def` keyword. 

```{code-cell} ipython3
def greeting_initial(name):
    '''
    greet the person named
    '''
    print('hello', name)
```

the docstring is a string defined with `'''` as a multline comment that is used for help 

```{code-cell} ipython3
help(greeting_initial)
```

::::{tip}
Remember you can use <kbd>shift</kbd> + <kbd>tab</kbd>  to get help for functions inside a jupyter notebook whenever your cursor is inside of `()`
:::::

```{code-cell} ipython3
greeting_initial('sarah')
```

::::::::{exercise} 
:label: fxeval
Is this a good function?

if not, how could it be better?

```Python
def greeting_initial(name):
    '''
    greet the person named
    '''
    print('hello', name)
```
::::::::


::::::::{solution} fxeval
:class: dropdown

No, that function had only a {term}`side effect` and it did not return a value. 
:::::::::


This is a better function, because it returns a value
```{code-cell} ipython3
def greeting(name):
    '''
    greet the person named
    '''
    return 'hello ' + name
```


Calling the two functions does not look that differnt
```{code-cell} ipython3
greeting('sarah')
```

```{code-cell} ipython3
greeting_initial('sarah')
```

but if we check what they return: 
```{code-cell} ipython3
type(greeting('sarah')), type(greeting_initial('sarah'))
```


Remember, everything is an object, so we can evne check properties fo the function: 

```{code-cell} ipython3
type(greeting)
```

We could look at the docstring manually
```{code-cell} ipython3
greeting.__doc__
```

Or even see what function we have: 

```{code-cell} ipython3
greeting.__name__
```

## Modules

We can also write code in a separate file and then import it

```{literalinclude} example.py
```

```{code-cell} ipython3
import example
```

```{code-cell} ipython3
example.greeting('sarah')
```

```{code-cell} ipython3
help(example.greeting)
```

We can also import only a part of it

```{code-cell} ipython3
from example import name
name
```


## Conditionals

Conditionals allow us to create flow here

The boolean expression, below (`len(name)< 5`) can then be used in all sorts of flows. 

```{code-cell} ipython3
if len(name) < 5:
    print('short')
else:
    print('long')
```

## Iterables

::::{important}
The term iterable, below is treated as a glossary entry. Hover over it to see the definition, without having to leave the page. 
::::


strings are {term}`iterable` type, meaning that theycan be indexed into, or their elements iterated over.  For a more technical definition, see the [official python glossary entry](https://docs.python.org/3/glossary.html#term-iterable)


```{code-cell} ipython3
type(name)
```


we can select one element
```{code-cell} ipython3
name[0]
```

negative numbers count from the right. 
```{code-cell} ipython3
name[-1]
```

or multiple, this is called a {term}`slice` or slicing.  
```{code-cell} ipython3
name[1:3]
```

notice that the string, {eval}`name`, the characters in positions 1,2,3 would be 
{eval}`name[1]` 

```{code-cell} ipython3
name[3]
```

### lists

Lists are defined with `[]`
```{code-cell} ipython3
ages = [25,34,64,24,56,23,45,48]
```

we can index them as well
```{code-cell} ipython3
a= ages[2]
a
```

We will transform this to ranges. 

First lets figure out how to calculate the lower nubmer of the range. 
```{code-cell} ipython3
str(int((a-5)/10)*10+5)
```

now the upper
```{code-cell} ipython3
str(int((a+5)/10)*10+4)
```

(lambdaex)=
We can make a small function to make this more concise.  This is called a {term}`lambda` or {term}`anonymous function`. 

It is a compact function 

```{code-cell} ipython3
lb = lambda a: str(int((a-5)/10)*10+5)
```

It is equivalant to the following: 

```Python
def lb(a):
    return str(int((a-5)/10)*10+5)
```

we can use it like any other function
```{code-cell} ipython3
lb(73)
```

we will make one for the upper bound as well
```{code-cell} ipython3
ub = lambda a: str(int((a+5)/10)*10+4)
```

(listcomprehension)=
Then we can apply it as a loop with a [list comprehension](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions). The [comprehension form](#listcompeq) is more compact than, but equivalent to, a [full for loop](#forloopeq)

```{code-cell} ipython3
:label: listcompeq
age_bins = ['-'.join([lb(a),ub(a)]) for a in ages]
age_bins
```

The above is equivalent to a longer loop. 

```{code-cell} ipython3
:label: forloopeq
age_bins = []

for a in ages: 
    age_bins.append('-'.join([lb(a),ub(a)]))
```

The comprehension has the advantage of Python knowing the length in advance and behinng visually more compact


What if we had a longer age list and we wanted to put the labels above only for ages 25-65 and otherwise put <25 or >65? 


```{code-cell} ipython3
ages = [25,34,64,24,56,23,45,48,99,76,21, 23,56,37,40]
```

We can use conditionals to get the true or false value
```{code-cell} ipython3
a = 24
a<25, int(a<25)
```
:::::{margin}
:::{note}
here I added some extra detail relative to in class
:::
:::::

we can use the `int` function to cast the boolean to an integer


```{code-cell} ipython3
type(a<25), type(int(a<25))
```

If we try different values, we can test that it works as expected
```{code-cell} ipython3
a = 38
a<25, int(a<25)
```

and in another case
```{code-cell} ipython3
a>65
```

If we combine the two, it gives us an expression that gives -1,0, or 1 depending on where the value falls. 

```{code-cell} ipython3
(a<25)*-1 + int(a>65)
```

::::{exercise} 
:label: lambda-prac
Write a list comprehension that computes the above expression (`(a<25)*-1 + int(a>65)`) for each element in the list. Use a lambda for the expression
:::::


```{code-cell} ipython3
age_bin_dict = {-1:lambda a:'<25',0:lambda a: '-'.join([lb(a),ub(a)]),
                1:lambda a:'65+'}
```

```{code-cell} ipython3
age_bin_dict
```

```{code-cell} ipython3
[age_bin_dict[(a<25)*-1 + int(a>65)](a) for a in ages]
```

```{code-cell} ipython3

```


## Questions


### How do I add words into the table of contents? 


Create a [heading](#mdheading) in a markdown cell. 


::::{tip}
hover over  heading above to see the syntax. 
::::


### How else can lambdas be used? 

They can be used for anything, including with any data type, as long as it can be defined simply. 

Best practice is to only use them for small things. 

For example if we had a list of short phrases and wanted to turn them all to camel case

```{code-cell} ipython3
phrases = ['hello friend', 'data frame', 'prismia chat']
camel_case = lambda s: ''.join([si.title() for si in s.split()])

[camel_case(p) for p in phrases]
```

### in python isnt it possible to separate code onto multiple lines for readability sakes?

Yes, for example this cell
```{code-cell} ipython3
age_bin_dict = {-1:lambda a:'<25',
                 0:lambda a: '-'.join([lb(a),ub(a)]),
                 1:lambda a:'65+'}
```

and this one

```{code-cell} ipython3
age_bin_dict = {-1:lambda a:'<25', 0:lambda a: '-'.join([lb(a),ub(a)]), 1:lambda a:'65+'}
```
Do the same thing, but the first is a lot easier to read

### In what cases should switch be used instead of dictionary?

Sometimes you need to pass a thing like the above into another function, then it needs to be an object that can be passed, that is what a dictionary is for.  

For example, we will use dictionaries to tell `pandas` to compute different statistics on different columns of a dataset. 

If it is in a regular flow program, a switch type structure could be better. The dictionary based case handling was the original Pythonic way to do this, because Python does not have a regular switch. It has  [match](https://docs.python.org/3/tutorial/controlflow.html#match-statements) which was introduced in 3.9 (I misremembered in class, it's older than I thought). This is under the hood different, but the details of the differences are beyond this course. 

### How can I practice or know more about writing functions like what we did today

For example with this piece: 
```{code-cell} ipython3
['-'.join([lb(a), ub(a)]) for a in ages]
```

One way to understand it better is to run the separatie parts of it one at a time. 

So, for example by removing the `'-'.join()` we get a list of lists instead
```{code-cell} ipython3
[[lb(a), ub(a)] for a in ages]
```

We can make a plain loop too:
```{code-cell} ipython3
[a for a in ages]
```

```{code-cell} ipython3
[a for a in ages] == ages
```


### what would be best way to learn to get more comfortable writing in juypiter?

Practice! 

You can follow along in class and you can go back after class and add more detail to your own notes. 

## Solutions

::::{solution} lambda-prac
```Python
cond_val = lambda a: (a<25)*-1 + int(a>65)
[cond_val(a) for a in ages]
```
:::::
