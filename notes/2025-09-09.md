---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.17.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Python Review



## Closing Jupyter server.

In the terminal use Ctrl+C (actually control, not command on mac).

It will ask you a question and give options, read and follow 


**or**

do ctrl+C a second time. 

A jupyter server typically runs at `localhost:8888`, but if you have multiple servers running the count increases. 


Once I saw a student in office hours working on `localhost:8894` asking why their code kept crashing.

```{important}
Remember to close your jupyter server
```

+++

## Functions

```{code-cell} ipython3
def greeting(name):
    '''
    greet the person named
    '''
    print('hello', name)
```

```{code-cell} ipython3
help(greeting)
```

```{code-cell} ipython3
greeting('sarah')
```

Is this a good function?

if not, how could it be better?

```Python
def greeting(name):
    '''
    greet the person named
    '''
    print('hello', name)
```

```{code-cell} ipython3
def greeting(name):
    '''
    greet the person named
    '''
    return 'hello ' + name
```

```{code-cell} ipython3
greeting('sarah')
```

```{code-cell} ipython3
type(greeting('sarah'))
```

```{code-cell} ipython3
import example
```

```{code-cell} ipython3
example.greeting('sarah')
```

```{code-cell} ipython3
help(example.greeting)
```

## Conditionals

```{code-cell} ipython3
name = 'sarah'
```

```{code-cell} ipython3
if len(name) < 5:
    print('short')
else:
    print('long')
```

## Iterables

::::{important}
The term iterable, below is treated as a glossary entry. Hover over it to see the definition, without having to leave the page. 
::::


strings are {term}`iterable` type, meaning that theycan be indexed into, or their elements iterated over.  For a more technical definition, see the [official python glossary entry](https://docs.python.org/3/glossary.html#term-iterable)


```{code-cell} ipython3
type(name)
```


we can select one element
```{code-cell} ipython3
name[0]
```

negative numbers count from the right. 
```{code-cell} ipython3
name[-1]
```

or multiple, this is called a {term}`slice` or slicing.  
```{code-cell} ipython3
name[1:3]
```

notice that the string, {eval}`name`, the characters in positions 1,2,3 would be 
{eval}`name[1]` 

```{code-cell} ipython3
name[3]
```

### lists

```{code-cell} ipython3
ages = [25,34,64,24,56,23,45,48]
```

```{code-cell} ipython3
a= ages[2]
a
```

```{code-cell} ipython3
str(int((a-5)/10)*10+5)
```

```{code-cell} ipython3
str(int((a+5)/10)*10+4)
```

```{code-cell} ipython3
lb = lambda a: str(int((a-5)/10)*10+5)
```


```Python
def lb(a):
    return str(int((a-5)/10)*10+5)
```

```{code-cell} ipython3
lb(73)
```

```{code-cell} ipython3
ub = lambda a: str(int((a+5)/10)*10+4)
```

```{code-cell} ipython3
'.'.join('ajs')
```

```{code-cell} ipython3
['-'.join([lb(a),ub(a)]) for a in ages]
```

```{code-cell} ipython3
ages = [25,34,64,24,56,23,45,48,99,76,21, 23,56,37,40]
```

```{code-cell} ipython3
a<25
```

```{code-cell} ipython3
a>65
```

```{code-cell} ipython3
(a<25)*-1 + int(a>65)
```

```{code-cell} ipython3
age_bin_dict = {-1:lambda a:'<25',0:lambda a: '-'.join([lb(a),ub(a)]),
                1:lambda a:'65+'}
```

```{code-cell} ipython3
age_bin_dict
```

```{code-cell} ipython3
[age_bin_dict[(a<25)*-1 + int(a>65)](a) for a in ages]
```

```{code-cell} ipython3

```
